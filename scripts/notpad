#!/bin/bash
echo "=================================="
echo "ARCHIPEL - INSTALLATION RAPIDE"
echo "=================================="

# Nettoyage
rm -rf archipel 2>/dev/null

# CrÃ©ation du dossier
mkdir -p archipel
cd archipel

# CrÃ©ation des dossiers
mkdir -p network protocol crypto peer storage tests

# Fichiers vides __init__.py
touch __init__.py
touch network/__init__.py protocol/__init__.py crypto/__init__.py peer/__init__.py storage/__init__.py tests/__init__.py

# Fichier requirements.txt
echo "cryptography==41.0.7" > requirements.txt

# Fichier main.py
cat > main.py << 'EOF'
import argparse
import time
from crypto.manager import CryptoManager
from network.udp_discovery import UDPDiscoveryService

def main():
    parser = argparse.ArgumentParser(description='ARCHIPEL Node')
    parser.add_argument('--port', type=int, default=38834, help='TCP port')
    parser.add_argument('--discover', action='store_true', help='Enable discovery')
    args = parser.parse_args()
    
    print("ðŸš€ ARCHIPEL Node Starting...")
    crypto = CryptoManager()
    print(f"ðŸ“‹ Node ID: {crypto.node_id.hex()[:16]}...")
    
    if args.discover:
        discovery = UDPDiscoveryService(crypto.node_id, args.port)
        discovery.start()
        discovery.start_announce_loop()
        print(f"ðŸ“¡ Discovery enabled on port {args.port}")
    
    print("âœ… Node ready")
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nðŸ‘‹ Shutting down...")
        if args.discover:
            discovery.stop()

if __name__ == "__main__":
    main()
EOF

# Fichier crypto/manager.py
mkdir -p crypto
cat > crypto/manager.py << 'EOF'
import os
import hashlib
import hmac
from cryptography.hazmat.primitives.asymmetric import ed25519
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

class CryptoManager:
    def __init__(self):
        self._private_key = ed25519.Ed25519PrivateKey.generate()
        self._public_key = self._private_key.public_key()
        self.node_id = hashlib.sha256(
            self._public_key.public_bytes_raw()
        ).digest()[:32]
        self._symmetric_key = None
    
    @property
    def public_key_bytes(self) -> bytes:
        return self._public_key.public_bytes_raw()
    
    def sign(self, data: bytes) -> bytes:
        return self._private_key.sign(data)
    
    def compute_hmac(self, key: bytes, data: bytes) -> bytes:
        return hmac.new(key, data, hashlib.sha256).digest()
    
    def verify_hmac(self, key: bytes, data: bytes, received_hmac: bytes) -> bool:
        computed = self.compute_hmac(key, data)
        return hmac.compare_digest(computed, received_hmac)
    
    def establish_symmetric_key(self, peer_public_key: bytes) -> bytes:
        peer_key = ed25519.Ed25519PublicKey.from_public_bytes(peer_public_key)
        shared_secret = self._private_key.exchange(peer_key)
        hkdf = HKDF(
            algorithm=hashes.SHA256(),
            length=32,
            salt=None,
            info=b'ARCHIPEL-SESSION-KEY',
        )
        self._symmetric_key = hkdf.derive(shared_secret)
        return self._symmetric_key
EOF

# Fichier network/udp_discovery.py
mkdir -p network
cat > network/udp_discovery.py << 'EOF'
import socket
import struct
import threading
import time
from typing import Optional, Callable, Set

class UDPDiscoveryService:
    MULTICAST_GROUP = '224.0.0.251'
    UDP_DISCOVERY_PORT = 38833
    DISCOVERY_INTERVAL = 30
    
    def __init__(self, node_id: bytes, port: int, callback: Optional[Callable] = None):
        self.node_id = node_id
        self.tcp_port = port
        self.callback = callback
        self.running = False
        self.socket = None
        self.thread = None
        self._lock = threading.Lock()
        self.discovered_peers: Set[bytes] = set()
    
    def start(self):
        if self.running:
            return
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.socket.bind(('', self.UDP_DISCOVERY_PORT))
            mreq = struct.pack("4sl", socket.inet_aton(self.MULTICAST_GROUP), socket.INADDR_ANY)
            self.socket.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
            self.socket.settimeout(1.0)
            self.running = True
            self.thread = threading.Thread(target=self._listen_loop, daemon=True)
            self.thread.start()
        except Exception as e:
            if self.socket:
                self.socket.close()
            raise RuntimeError(f"Failed to start UDP discovery: {e}")
    
    def stop(self):
        self.running = False
        if self.thread:
            self.thread.join(timeout=2.0)
        if self.socket:
            self.socket.close()
            self.socket = None
    
    def _listen_loop(self):
        while self.running:
            try:
                data, addr = self.socket.recvfrom(1024)
                if len(data) == 34:
                    node_id = data[:32]
                    port = struct.unpack('!H', data[32:34])[0]
                    with self._lock:
                        if node_id not in self.discovered_peers:
                            self.discovered_peers.add(node_id)
                            if self.callback:
                                self.callback(node_id, addr[0], port)
            except socket.timeout:
                continue
            except Exception:
                continue
    
    def announce(self):
        if not self.socket:
            return
        packet = self.node_id + struct.pack('!H', self.tcp_port)
        try:
            self.socket.sendto(packet, (self.MULTICAST_GROUP, self.UDP_DISCOVERY_PORT))
        except Exception:
            pass
    
    def start_announce_loop(self):
        def _loop():
            while self.running:
                self.announce()
                time.sleep(self.DISCOVERY_INTERVAL)
        thread = threading.Thread(target=_loop, daemon=True)
        thread.start()
EOF

# Fichier protocol/constants.py
mkdir -p protocol
cat > protocol/constants.py << 'EOF'
MAGIC = b'ARCH'
class PacketType:
    HELLO = 0x01
    PEER_LIST = 0x02
    MSG = 0x03
    CHUNK_REQ = 0x04
    CHUNK_DATA = 0x05
    MANIFEST = 0x06
    ACK = 0x07
NODE_ID_LENGTH = 32
HMAC_LENGTH = 32
MAX_PACKET_SIZE = 65536
EOF

# Fichier protocol/packet.py
cat > protocol/packet.py << 'EOF'
import struct
from .constants import *

class ArchipelPacket:
    __slots__ = ['packet_type', 'node_id', 'payload', 'hmac']
    
    def __init__(self, packet_type, node_id, payload, hmac):
        self.packet_type = packet_type
        self.node_id = node_id
        self.payload = payload
        self.hmac = hmac
    
    def serialize(self):
        fmt = f'!4s B {NODE_ID_LENGTH}s I {len(self.payload)}s {HMAC_LENGTH}s'
        return struct.pack(fmt, MAGIC, self.packet_type, self.node_id, 
                          len(self.payload), self.payload, self.hmac)
    
    @classmethod
    def deserialize(cls, data):
        if len(data) < 4 + 1 + NODE_ID_LENGTH + 4 + HMAC_LENGTH:
            raise ValueError("Packet too short")
        if data[:4] != MAGIC:
            raise ValueError("Invalid MAGIC")
        offset = 4
        packet_type = data[offset]
        offset += 1
        node_id = data[offset:offset+NODE_ID_LENGTH]
        offset += NODE_ID_LENGTH
        payload_len = struct.unpack('!I', data[offset:offset+4])[0]
        offset += 4
        if len(data) < offset + payload_len + HMAC_LENGTH:
            raise ValueError("Packet truncated")
        payload = data[offset:offset+payload_len]
        offset += payload_len
        hmac_received = data[offset:offset+HMAC_LENGTH]
        return cls(packet_type, node_id, payload, hmac_received)
EOF

# Fichier tests/test_packet.py
mkdir -p tests
cat > tests/test_packet.py << 'EOF'
import unittest
import os
import sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from protocol.packet import ArchipelPacket
from protocol.constants import PacketType
from crypto.manager import CryptoManager

class TestPacketProtocol(unittest.TestCase):
    def setUp(self):
        self.crypto = CryptoManager()
    
    def test_serialization(self):
        packet = ArchipelPacket(PacketType.HELLO, self.crypto.node_id, b"test", os.urandom(32))
        data = packet.serialize()
        packet2 = ArchipelPacket.deserialize(data)
        self.assertEqual(packet.packet_type, packet2.packet_type)
        self.assertEqual(packet.node_id, packet2.node_id)

if __name__ == '__main__':
    unittest.main()
EOF

# README.md
cat > README.md << 'EOF'
# ARCHIPEL
## Sprint 0 - Fondations

Installation:
pip install -r requirements.txt

Lancement:
python main.py --discover

Tests:
python -m unittest discover tests/
EOF

cd ..
echo ""
echo "=================================="
echo "âœ… INSTALLATION TERMINÃ‰E"
echo "=================================="
echo "Pour dÃ©marrer : cd archipel && python main.py --discover"
